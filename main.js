//1
// function, პროგრამირებაში არის კოდის ბლოკი, რომელსაც გარკვეული ტიპის ამოცანების შესასრულებლად ვიყენებთ.

//2
//function call ანუ ფუნქციის გამოძახება, ნიშნავს, ფუნქციის შესრულებას. ამ დროს ფუნქციაში არსებული შიგთავსი if any-ის დახმარებით ასრულებს ამოცანას

//3
//code block ანუ კოდის ბლოკი, არის ერთი ან ერტზე მეტი ხაზის ჯგუფი, რომელსაც {} ასეთ ფრჩხილებში ვსვამთ.
//და რაც შეეხება მის მნიშვნელობას function-ში, ის იწერება ფუნქციის თავში და ფაქტიურად გვეხმარება, რომ ფუნქციაში არსებული კოდი ერთად დავაჯგუფოთ. რადგან მასში ვწერთ იმ ამოცანებს, რაც ფუნქციამ უნდა შეასრულოს.

//4
function greetUser(name) {
    return "Hello," + name + "!";
}

let greeting = greetUser("Lizi");
console.log(greeting); //output: "Hello Lizi"

//5
function reverseString(input) {
    let reversed = ""; //ცარიელი string შებრუნებული შედეგის შესანახად
    for (i = input.length -1; i >= 0; i--){ //ციკლი სტრიქონის დასასრულიდან დასაწყისამდე
        reversed += input[1]; //ეს ნიშნავს, რომ ყოველი სიმბოლო უნდა დაემატოს შემდეგს, ანუ ცარიელ string-ში სიტყვა Hello-ს თითოეული სიმბოლო უნდა ჩაჯდეს უკუღმა, 
    }
    return reversed; //ეს აწ უკვე უკუღმა ვერსიას დააბრუნებს
}

console.log(reversedString("Hello"));//და საბოლოოდ output იქნება, "olleH"

//6
//default argument ანუ ნაგულისხმევი არგუმენტი. არის მნიშვნელობა, რომელსაც ფუნცქია ავტომატურად იყენებს, თუ არგუმენტი გამოძახებისას არ მიეწოდება. (როდესაც ფუნქციას სახელს არ ვარქმევთ).
//ამ შემთხვევაში ფუნქციის მნიშვნელობა განისაზღვრება მისი აღწერის დროს. თუკი გამოძახებისას პარამეტრს (ანუ იმას რასაც ფუნქციის სახელის შემდგომ ფრჩხილებში ვწერთ), აქვს რაიმე მნიშვნელობა, მაშინ ეს მნიშვნელობა გამოიყენება არგუმენტადაც. მაგრამ თუ პარამეტრი არ გადაეცემა მაშინ გამოიყენება ნაგულისხმევი მნიშვნელობა.

//7
//scope of variable - ნიშნავს, კოდში იმ კონკრეტულ ადგილს სადაც "ინახება" პარამეტრი, მანამ სანამ მას გამოვიყენებთ და ამ დროის განმავლობაში ის ჩვეულებრივ არის ხელმისაწვდომი.
//Lifetime of a Variable - ეს კი განსაზღვრავს, თუ რამდენი ხნის განმავლობაში შეიძლება გარკვეული პარამეტრის შენახვა.

//8
//return value - არის მნიშვნელობები, რომლებსაც ფუნქცია აბრუნებს მათი დასრულებისას. უფრო ზუსტად return-ს როდესაც ვწერთ, ამით ფუნქციას ვეუბნებით, რომ დაბრუნდეს ზემოთ იმ ხაზე რომელიც შესაბამება ფუნქციის არგუმენტში ჩაწერილს და იქიდან დააბრუნოს მნიშვნელობა.
//მგონი სწორად დავიმახსოვრე :)

//9
//undefind - რადგან როდესაც ფუნქციას არ ვუწერთ return-ს ის ნაგულისხმევ მნიშვნელობად, კონსოლში დაწერს undefind-ს.

//10
//კოდში არ გვაქ return მნიშვნელობა x * 2 -თან, ანუ კოდის ეს ხაზი ვერ წერს შესაბამისს პასუხს, შესაბამისად x-ის მნიშვნელობა, ფუნქციის გარეთ არ განახლებულა. აქედან გამომდინარე, რადგანაც კოდი ვერ აბურნებს რიცხვის მნიშვნელობას, კონსოლშიც გამოიტანს მნივნელობა "undefind"-ს.
//ამის მიხედვით კოდში x = foo(x); წესით მნიშვნელობად უნდა ენიჭებოდეს x, მაგრმა რადგან ზემოთ არსებული შეცდომის გამო foo(x) ვერ აბურნებს მნიშვნელობას, x იქნება Undefind.
//ამ კოდის მიზანია (foo(x)), რომ მიიღოს x-ის მნიშვნელობა, გაამრავლოს ის ორზე და შემდეგ დააბრუნოს შედეგი. და შემდეგ აწ უკვე მიღებული შედეგი უნდა მიენიჭოს x-ს რათა x განახლდეს ახალი მნიშვნელობით.
//საბოლოოდ ასე უნდა გამოყურებოდეს კოდი:
function foo(x) {
    return x * 2; //დააბურენს x-ის მნისვნელობას და გაამრავლებს ორზე
}

let x = 7;
x = foo(x);  // ამ შემთხვევაში, კოდის ეს ხაზი დააბრუნებს x-ის მნისვნელობას და გაანახლებს მას
console.log(x);  // Output: 14


//11
//bar() ფუნქცია, მხოლოდ ადგილობრივად ცვლის x-ის მნიშვნელობას, რადგან მას არ უწერია return რომ მთლიანად ფუნქციაში შეიცვალოს x-ის მნიშვნელობა. foo()-ში bar()-ის გამოძახებაც ასევე შცვლის მხოლოდ ლოკალურად x-ის მნიშვნელობას 
//ამას გარდა, foo(x) არ გადასცემს x-ს სწორად bar() ფუნქციაში, ანუ x კი გადაეცემა bar()-ს თუმცა ერი მხრივ ეს არც არის საჭირო, რადგან bar() მისი პარამეტრი აქვს (x = 8), გარდა ამისა x არ იცველბა მთლიანად ცვლადში.
//აქედან გამომდინარე, კოდის სწორი ვარიანტი იქნება ასეთი:
function bar() {
    x += 1;  // ამით ვცვლით გლობალურ x
}

function foo() {
    bar();   // ამ კოდის გამოძახებით, გლობალურად ვცლით x
    x *= 2;  // აქ კი ვხრდით x-ის მნიშვნელობას (ვამრავლებთ 2-ზე)
}

let x = 7;
foo();  // foo თავის თავში გამოძაებს bar-ს რის შედეგადაც x-ის მნიშვნელობა მთლიანად შეიცვლება
console.log(x);  // შედეგი: 16

//12
//ეს კარგად ვერ გავიგე :(

//13
function sumOddNumbers(arr) {
    let sum = 0;  // აქ ვინახავთ რიცხვების ჯამს
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] % 2 !== 0) {  // ეს შეამოწმებს რიცხვი არის თუ არა odd
            sum += arr[i];  // აქ კი odd რიცხვი დამეტება ჯამს
        }
    }
    return sum;  // აქ საბოლოო ჯამი დაბრუნდება
}

let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
let result = sumOddNumbers(numbers);
console.log(result);  // Output: 25 (1 + 3 + 5 + 7 + 9)

//14
function isPalindrome(str) {
    let reversedStr = '';  // აქ ვწერთ ცარიელ სტრიქონდ, რომ შევინახოთ უკუღმა წაკითხული სიტყვის მნიშვნელობა 
    
    // ციკლი, რომელიც სიტყვას შემოაბურენს, ანუ მას გაივლის ბოლოდან დასაწყისამდე 
    for (let i = str.length - 1; i >= 0; i--) {
        reversedStr += str[i];  // ამ კოდით, თითოეული სიმბოლო დამეტება უკუღმა წაკითხულ string-ს
    }
    
    // trueს დააბრუნებს თუ ჩვეულებრივი და უკუღმა წაკიტხული string-ები თანაბარია, სხვა შემთხვევაში კი დაწერს false 
    return str === reversedStr;
}

console.log(isPalindrome("hello"));  // Output: false
console.log(isPalindrome("elle"));  // Output: true



